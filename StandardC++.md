# Standard C++

基于C++11（都什么年代了，还在整C++11？八股害人啊）

## 一：C++11的“新”特性

### nullptr

一个新关键字，用于表示指针指向no value，可以被自动转化为各种指针类型，但是不会被转化为整数

*比NULL好，因为NULL的本质就是整数0*

### auto

通过auto声明变量、对象，可以自动推到其类型，在处理表达式时有奇效

```c++
auto l = [](int x) -> {...};
```

### 一致性初始化

一致性初始化（Uniform Initiallization），简单来说就是可以用大括号来做初始化

```c++
int v[] {1, 2, 3};
vector<int> v2 {1, 2, 3};
complex<double> c{4.0, 3.0};
```

但是这个操作不支持**窄化（narrowing）**，即

```c++
int x = 5.3;	//x == 5
int y {5.3};	//Error
```

### 新的for循环

```c++
for(auto& item: lists){...}

for(int i : {1, 2, 3, 4}){...}
```

### 转移语意

转移语意（move semantic），用于避免非必要的拷贝和临时对象

比如一个函数定义为

```c++
void fun(const T& v){...}
```

当我们调用时

```c++
T t;
fun(t);		//1
fun(t+1);	//2
```

我们发现，第一种调用时，直接传了引用，没有拷贝和临时变量，而第二种，实际上是

```c++
T temp = t+1;		//T temp(t+1)或者 T temp.T(t+1)
fun(temp);
```

总之是调用了拷贝构造函数和生成了临时变量，这不是我们想要的，于是引入了左右值和转移语意的概念，然后就诞生了一种新的调用方式：

```c++
fun(std::move(t+1));
```

`std::move`的作用是将其参数`t+1`变成一个**右值（rvalue reference）**，是一个`T&&`的类型

一旦一个类型被“标记”为右值，就意味着这是一个临时对象，你可以随意使用它的内容和资源

然后我们可以优化一下这个函数的定义

```c++
class T{
public:
  T (const T& lvalue);	//通过左值拷贝构造（根传统C++一样）
  T (T&& rvalue);		//通过右值move构造
}
void fun(T&& v){...}
```

右值被move以后，就变成有效但不确定的状态